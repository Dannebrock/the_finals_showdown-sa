{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Workspace/tournament-bracke/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js'\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\r\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey)"],"names":[],"mappings":";;;;AAEoB;AAFpB;;AAEA,MAAM;AACN,MAAM;AAEC,MAAM,WAAW,IAAA,kOAAY,EAAC,aAAa"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Workspace/tournament-bracke/components/tournament-context.tsx"],"sourcesContent":["\"use client\"\n\nimport React, { createContext, useContext, useState, useEffect, useCallback } from \"react\"\nimport { supabase } from \"@/lib/supabase\"\nimport type { TournamentState, Team, Group, Bo3Match, FinalMatch } from \"@/lib/types\"\n\ninterface TournamentContextType {\n  state: TournamentState\n  loading: boolean\n  refreshData: () => Promise<void>\n  setCurrentDay: (day: number) => void\n  getTeamById: (id: string) => Team | undefined\n  addTeam: (team: { name: string; logo: string | null }) => Promise<void>\n  deleteTeam: (teamId: string) => Promise<void>\n  addTeamToGroup: (groupId: string, teamId: string, position: number) => Promise<void>\n  removeTeamFromGroup: (groupId: string, teamId: string) => Promise<void>\n  updateTeamCashout: (groupId: string, teamId: string, cashout: number) => Promise<void>\n  updateTeamStatus: (groupId: string, teamId: string, status: string) => Promise<void>\n  lockGroupAndCreateBo3: (groupId: string) => Promise<void>\n  updateGroup: (groupId: string, data: Partial<Group>) => Promise<void>\n  updateBo3Match: (matchId: string, data: Partial<Bo3Match>) => Promise<void>\n  initFinalMatch: (teamIds: string[]) => Promise<void>\n  updateFinalPoints: (teamId: string, points: number) => Promise<void>\n}\n\nconst TournamentContext = createContext<TournamentContextType | undefined>(undefined)\n\n// --- MAPA DE PROGRESSÃO (ÁRVORE DE DECISÃO) ---\n// Configuração exata conforme sua regra:\n// G1/G2 -> Upper Winner vai pro G9 (Domingo), Upper Loser vai pro G5, Lower Winner vai pro G5.\n// G3/G4 -> Upper Winner vai pro G10 (Domingo), Upper Loser vai pro G6, Lower Winner vai pro G6.\n\ninterface ProgressionRule {\n  upperWinner: string; // Vencedor do 1º vs 2º (Vai para Domingo)\n  upperLoser: string;  // Perdedor do 1º vs 2º (Cai para Repescagem)\n  lowerWinner: string; // Vencedor do 3º vs 4º (Sobrevive na Repescagem)\n}\n\nconst PROGRESSION_MAP: Record<string, ProgressionRule> = {\n  G1: { upperWinner: \"G9\", upperLoser: \"G5\", lowerWinner: \"G5\" },\n  G2: { upperWinner: \"G9\", upperLoser: \"G5\", lowerWinner: \"G5\" },\n  G3: { upperWinner: \"G10\", upperLoser: \"G6\", lowerWinner: \"G6\" },\n  G4: { upperWinner: \"G10\", upperLoser: \"G6\", lowerWinner: \"G6\" },\n}\n\nexport function TournamentProvider({ children }: { children: React.ReactNode }) {\n  const [loading, setLoading] = useState(true)\n  const [currentDay, setCurrentDay] = useState(1)\n  const [state, setState] = useState<TournamentState>({\n    teams: [],\n    groups: [],\n    bo3Matches: [],\n    finalMatch: null,\n    currentDay: 1,\n  })\n\n  // --- BUSCAR DADOS DO BANCO ---\n  const fetchData = useCallback(async () => {\n    try {\n      setLoading(true)\n\n      // 1. Buscar Times\n      const { data: teamsData } = await supabase.from(\"teams\").select(\"*\").order(\"name\")\n      \n      // 2. Buscar Grupos e Times nos Grupos\n      const { data: groupsData } = await supabase\n        .from(\"groups\")\n        .select(`\n          *,\n          group_teams (\n            team_id, position, cashout, status,\n            teams (name, logo_url)\n          )\n        `)\n        .order(\"id\")\n\n      // 3. Buscar Partidas Bo3\n      const { data: bo3Data } = await supabase.from(\"bo3_matches\").select(\"*\")\n\n      // 4. Buscar Final\n      const { data: finalData } = await supabase\n        .from(\"final_match\")\n        .select(`*, final_teams(*)`)\n        .single()\n\n      // --- TRANSFORMAÇÃO DE DADOS (SQL -> APP) ---\n      \n      const formattedTeams: Team[] = (teamsData || []).map(t => ({\n        id: t.id,\n        name: t.name,\n        logo: t.logo_url\n      }))\n\n      const formattedGroups: Group[] = (groupsData || []).map(g => ({\n        id: g.id,\n        name: g.name,\n        phase: g.phase,\n        day: g.day,\n        type: g.type as any,\n        locked: g.is_locked,\n        teams: (g.group_teams || []).map((gt: any) => ({\n          teamId: gt.team_id,\n          position: gt.position,\n          cashout: gt.cashout,\n          status: gt.status,\n          name: gt.teams?.name || \"Unknown\",\n          logo: gt.teams?.logo_url || null\n        }))\n      }))\n\n      const formattedBo3: Bo3Match[] = (bo3Data || []).map(b => ({\n        id: b.id,\n        phase: b.phase,\n        day: b.day,\n        team1Id: b.team1_id,\n        team2Id: b.team2_id,\n        team1Wins: b.team1_wins,\n        team2Wins: b.team2_wins,\n        winnerId: b.winner_id,\n        completed: b.completed,\n        sourceGroupId: b.source_group,\n        matchType: b.match_order === 1 ? \"upper\" : \"lower\"\n      }))\n\n      let formattedFinal: FinalMatch | null = null\n      if (finalData) {\n        formattedFinal = {\n          id: finalData.id,\n          winnerId: finalData.winner_id,\n          completed: finalData.completed,\n          teams: (finalData.final_teams || []).map((ft: any) => ({\n            teamId: ft.team_id,\n            points: ft.points\n          }))\n        }\n      }\n\n      setState(prev => ({\n        ...prev,\n        teams: formattedTeams,\n        groups: formattedGroups,\n        bo3Matches: formattedBo3,\n        finalMatch: formattedFinal\n      }))\n\n    } catch (error) {\n      console.error(\"Erro ao buscar dados:\", error)\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  useEffect(() => {\n    fetchData()\n  }, [fetchData])\n\n  // --- HELPERS ---\n  \n  const getTeamById = (id: string) => {\n    return state.teams.find((t) => t.id === id)\n  }\n\n  // --- ACTIONS ---\n\n  const addTeam = async (team: { name: string; logo: string | null }) => {\n    await supabase.from(\"teams\").insert({ name: team.name, logo_url: team.logo })\n    fetchData()\n  }\n\n  const deleteTeam = async (teamId: string) => {\n    await supabase.from(\"teams\").delete().eq(\"id\", teamId)\n    fetchData()\n  }\n\n  // Função auxiliar interna para mover times (evita duplicação)\n  const moveTeamToGroup = async (groupId: string, teamId: string) => {\n    // 1. Verifica se o time já está lá\n    const { data: existing } = await supabase\n        .from(\"group_teams\")\n        .select(\"*\")\n        .match({ group_id: groupId, team_id: teamId })\n        .single();\n    \n    if (existing) return; // Já foi movido, não faz nada\n\n    // 2. Insere no novo grupo\n    await supabase.from(\"group_teams\").insert({\n      group_id: groupId,\n      team_id: teamId,\n      position: 0,\n      status: 'playing'\n    });\n    console.log(`Time ${teamId} movido para ${groupId}`);\n  }\n\n  const addTeamToGroup = async (groupId: string, teamId: string, position: number) => {\n    await moveTeamToGroup(groupId, teamId);\n    fetchData()\n  }\n\n  const removeTeamFromGroup = async (groupId: string, teamId: string) => {\n    await supabase.from(\"group_teams\").delete().match({ group_id: groupId, team_id: teamId })\n    fetchData()\n  }\n\n  const updateTeamCashout = async (groupId: string, teamId: string, cashout: number) => {\n    await supabase\n      .from(\"group_teams\")\n      .update({ cashout })\n      .match({ group_id: groupId, team_id: teamId })\n    \n    // Atualização otimista\n    const newGroups = state.groups.map(g => {\n      if (g.id !== groupId) return g\n      return {\n        ...g,\n        teams: g.teams.map(t => t.teamId === teamId ? { ...t, cashout } : t)\n      }\n    })\n    setState(prev => ({ ...prev, groups: newGroups }))\n  }\n\n  const updateTeamStatus = async (groupId: string, teamId: string, status: string) => {\n    await supabase\n      .from(\"group_teams\")\n      .update({ status })\n      .match({ group_id: groupId, team_id: teamId })\n    fetchData()\n  }\n\n  const lockGroupAndCreateBo3 = async (groupId: string) => {\n    const group = state.groups.find(g => g.id === groupId)\n    if (!group) return\n\n    const sortedTeams = [...group.teams].sort((a, b) => b.cashout - a.cashout)\n    if (sortedTeams.length < 4) {\n      alert(\"Precisa de 4 times para fechar o grupo.\")\n      return\n    }\n\n    const { error: lockError } = await supabase\n      .from(\"groups\")\n      .update({ is_locked: true })\n      .eq(\"id\", groupId)\n    \n    if (lockError) return\n\n    // 1º vs 2º (Upper - Match Order 1)\n    const match1 = {\n      phase: group.phase,\n      day: group.day,\n      team1_id: sortedTeams[0].teamId,\n      team2_id: sortedTeams[1].teamId,\n      source_group: groupId,\n      match_order: 1 \n    }\n\n    // 3º vs 4º (Lower - Match Order 2)\n    const match2 = {\n      phase: group.phase,\n      day: group.day,\n      team1_id: sortedTeams[2].teamId,\n      team2_id: sortedTeams[3].teamId,\n      source_group: groupId,\n      match_order: 2\n    }\n\n    await supabase.from(\"bo3_matches\").insert([match1, match2])\n    fetchData()\n  }\n\n  const updateGroup = async (groupId: string, data: Partial<Group>) => {\n    const updateData: any = {}\n    if (data.locked !== undefined) updateData.is_locked = data.locked\n    \n    await supabase.from(\"groups\").update(updateData).eq(\"id\", groupId)\n    fetchData()\n  }\n\n  // --- ATUALIZAÇÃO DE BO3 COM A LÓGICA DE PROGRESSÃO ---\n  const updateBo3Match = async (matchId: string, data: Partial<Bo3Match>) => {\n    const updateData: any = {}\n    if (data.team1Wins !== undefined) updateData.team1_wins = data.team1Wins\n    if (data.team2Wins !== undefined) updateData.team2_wins = data.team2Wins\n\n    let currentMatch = state.bo3Matches.find(m => m.id === matchId)\n    \n    // Fallback DB lookup\n    if (!currentMatch) {\n       const { data: dbMatch } = await supabase.from('bo3_matches').select('*').eq('id', matchId).single()\n       if(dbMatch) {\n         currentMatch = {\n           id: dbMatch.id,\n           team1Id: dbMatch.team1_id,\n           team2Id: dbMatch.team2_id,\n           team1Wins: dbMatch.team1_wins,\n           team2Wins: dbMatch.team2_wins,\n           winnerId: dbMatch.winner_id,\n           completed: dbMatch.completed,\n           sourceGroupId: dbMatch.source_group,\n           matchType: dbMatch.match_order === 1 ? \"upper\" : \"lower\",\n           phase: dbMatch.phase,\n           day: dbMatch.day\n         }\n       }\n    }\n\n    let winnerId: string | null = null\n    let loserId: string | null = null\n    let isCompleted = false\n\n    if (currentMatch) {\n       const t1Wins = data.team1Wins ?? currentMatch.team1Wins\n       const t2Wins = data.team2Wins ?? currentMatch.team2Wins\n       \n       if (t1Wins === 2) {\n         winnerId = currentMatch.team1Id\n         loserId = currentMatch.team2Id\n         updateData.winner_id = winnerId\n         updateData.completed = true\n         isCompleted = true\n       } else if (t2Wins === 2) {\n         winnerId = currentMatch.team2Id\n         loserId = currentMatch.team1Id\n         updateData.winner_id = winnerId\n         updateData.completed = true\n         isCompleted = true\n       }\n\n       // --- PROGRESSÃO AUTOMÁTICA ---\n       if (isCompleted && winnerId && loserId && currentMatch.sourceGroupId) {\n          const sourceG = currentMatch.sourceGroupId\n          const type = currentMatch.matchType // \"upper\" ou \"lower\"\n          const targets = PROGRESSION_MAP[sourceG]\n\n          if (targets) {\n            // REGRA: UPPER MATCH (1º vs 2º)\n            if (type === \"upper\") {\n                // VENCEDOR -> Vai para Domingo (G9 ou G10)\n                await moveTeamToGroup(targets.upperWinner, winnerId);\n                \n                // PERDEDOR -> Tem segunda chance no Elimination (G5 ou G6)\n                await moveTeamToGroup(targets.upperLoser, loserId);\n            } \n            // REGRA: LOWER MATCH (3º vs 4º)\n            else if (type === \"lower\") {\n                // VENCEDOR -> Vai para Elimination (G5 ou G6)\n                await moveTeamToGroup(targets.lowerWinner, winnerId);\n                \n                // PERDEDOR -> Está eliminado (Não fazemos nada, ele não é movido pra lugar nenhum)\n            }\n          }\n       }\n    }\n\n    await supabase.from(\"bo3_matches\").update(updateData).eq(\"id\", matchId)\n    fetchData()\n  }\n\n  const initFinalMatch = async (teamIds: string[]) => {\n    const { data: final, error } = await supabase\n      .from(\"final_match\")\n      .insert({ completed: false })\n      .select()\n      .single()\n\n    if (error || !final) return\n\n    const teamInserts = teamIds.map(tid => ({\n      final_id: final.id,\n      team_id: tid,\n      points: 0\n    }))\n\n    await supabase.from(\"final_teams\").insert(teamInserts)\n    fetchData()\n  }\n\n  const updateFinalPoints = async (teamId: string, points: number) => {\n    if (!state.finalMatch) return\n\n    await supabase\n      .from(\"final_teams\")\n      .update({ points })\n      .match({ final_id: state.finalMatch.id, team_id: teamId })\n\n    if (points >= 5) {\n      await supabase\n        .from(\"final_match\")\n        .update({ completed: true, winner_id: teamId })\n        .eq(\"id\", state.finalMatch.id)\n    }\n\n    fetchData()\n  }\n\n  return (\n    <TournamentContext.Provider\n      value={{\n        state: { ...state, currentDay },\n        loading,\n        refreshData: fetchData,\n        setCurrentDay,\n        getTeamById,\n        addTeam,\n        deleteTeam,\n        addTeamToGroup,\n        removeTeamFromGroup,\n        updateTeamCashout,\n        updateTeamStatus,\n        lockGroupAndCreateBo3,\n        updateGroup,\n        updateBo3Match,\n        initFinalMatch,\n        updateFinalPoints,\n      }}\n    >\n      {children}\n    </TournamentContext.Provider>\n  )\n}\n\nexport const useTournament = () => {\n  const context = useContext(TournamentContext)\n  if (context === undefined) {\n    throw new Error(\"useTournament must be used within a TournamentProvider\")\n  }\n  return context\n}"],"names":[],"mappings":"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"}}]
}